use anyhow::Result;
use base64::{engine::general_purpose, Engine as _};
use hmac::{Hmac, Mac};
use sha1::Sha1;
use std::{
    collections::HashMap,
    net::{IpAddr, SocketAddr},
    str::FromStr,
    sync::Arc,
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::sync::RwLock;
use tracing::info;
use turn::{
    auth::AuthHandler,
    relay::relay_static::RelayAddressGeneratorStatic,
    server::{config::*, Server},
    Error as TurnError,
};

type HmacSha1 = Hmac<Sha1>;

/// Temporary credentials for TURN authentication
#[derive(Clone, Debug)]
pub struct TurnCredentials {
    pub username: String,
    pub password: String,
    pub expires_at: u64,
}

/// Custom AuthHandler for dynamic credential generation
struct DynamicAuthHandler {
    credentials_store: Arc<RwLock<HashMap<String, TurnCredentials>>>,
    shared_secret: String,
}

impl DynamicAuthHandler {
    fn new(shared_secret: String) -> Self {
        Self {
            credentials_store: Arc::new(RwLock::new(HashMap::new())),
            shared_secret,
        }
    }

    async fn add_credentials(&self, credentials: TurnCredentials) {
        let mut store = self.credentials_store.write().await;
        store.insert(credentials.username.clone(), credentials);
    }
}

impl AuthHandler for DynamicAuthHandler {
    fn auth_handle(
        &self,
        username: &str,
        _realm: &str,
        _src_addr: SocketAddr,
    ) -> Result<Vec<u8>, TurnError> {
        // For temporary credentials generated by this server,
        // validate using HMAC-SHA1 with the shared secret
        let parts: Vec<&str> = username.split(':').collect();
        if parts.len() != 2 {
            return Err(TurnError::ErrFakeErr);
        }

        let expires_str = parts[0];
        let expires_at: u64 = expires_str.parse().map_err(|_| TurnError::ErrFakeErr)?;

        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        if now > expires_at {
            return Err(TurnError::ErrFakeErr);
        }

        // Generate the expected password using HMAC-SHA1
        let mut mac = HmacSha1::new_from_slice(self.shared_secret.as_bytes())
            .map_err(|_| TurnError::ErrFakeErr)?;
        mac.update(username.as_bytes());
        let expected_password = general_purpose::STANDARD.encode(mac.finalize().into_bytes());

        Ok(expected_password.into_bytes())
    }
}

/// Simple TURN server with temporary authentication
pub struct TurnServer {
    pub disabled: bool,
    listen_addr: SocketAddr,
    public_ip: Option<String>,
    credentials_store: Arc<RwLock<HashMap<String, TurnCredentials>>>,
    shared_secret: String,
    server: Arc<RwLock<Option<Server>>>,
    auth_handler: Arc<DynamicAuthHandler>,
}

impl TurnServer {
    pub async fn new(disabled: bool, listen_addr: &str, public_ip: Option<String>) -> Result<Self> {
        // Generate a random shared secret for HMAC
        let shared_secret: String = (0..32)
            .map(|_| rand::random::<u8>() as char)
            .collect::<String>();

        let credentials_store = Arc::new(RwLock::new(HashMap::new()));
        let auth_handler = Arc::new(DynamicAuthHandler::new(shared_secret.clone()));

        Ok(Self {
            disabled,
            listen_addr: listen_addr.parse()?,
            credentials_store,
            shared_secret,
            public_ip,
            server: Arc::new(RwLock::new(None)),
            auth_handler,
        })
    }

    /// Start the TURN server using the turn crate
    pub async fn start(&self) -> Result<()> {
        if self.disabled {
            info!("TURN server is disabled.");
            return Ok(());
        }

        info!(
            "TURN server listening on {}, public IP: {}",
            self.listen_addr,
            self.public_ip.as_deref().unwrap_or("<not set>")
        );

        // Create UDP socket connection
        let socket = tokio::net::UdpSocket::bind(self.listen_addr).await?;
        let conn = Arc::new(socket);

        // Determine public IP for relay address generator
        let relay_ip = if let Some(ref public_ip) = self.public_ip {
            IpAddr::from_str(public_ip)?
        } else {
            IpAddr::from_str("127.0.0.1")?
        };

        // Create relay address generator
        let relay_addr_generator = Box::new(RelayAddressGeneratorStatic {
            relay_address: relay_ip,
            address: "0.0.0.0".to_owned(),
            net: Arc::new(webrtc_util::vnet::net::Net::new(None)),
        });

        // Create server configuration
        let config = ServerConfig {
            conn_configs: vec![ConnConfig {
                conn,
                relay_addr_generator,
            }],
            realm: "rport.turn".to_owned(),
            auth_handler: self.auth_handler.clone(),
            channel_bind_timeout: Duration::from_secs(600), // 10 minutes
            alloc_close_notify: None,
        };

        // Create and start the TURN server
        let server = Server::new(config).await?;
        *self.server.write().await = Some(server);

        info!("TURN server started successfully");
        Ok(())
    }

    /// Generate temporary credentials valid for 1 minute
    pub async fn generate_credentials(&self) -> Option<TurnCredentials> {
        if self.disabled {
            return None;
        }

        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        let expires_at = now + 60; // Valid for 1 minute

        // Generate username with timestamp
        let username = format!("{}:{}", expires_at, rand::random::<u32>());

        // Generate password using HMAC-SHA1 with shared secret
        let mut mac = HmacSha1::new_from_slice(self.shared_secret.as_bytes())
            .expect("HMAC can take key of any size");
        mac.update(username.as_bytes());
        let password = general_purpose::STANDARD.encode(mac.finalize().into_bytes());

        let credentials = TurnCredentials {
            username: username.clone(),
            password: password.clone(),
            expires_at,
        };

        // Store credentials in our auth handler
        self.auth_handler.add_credentials(credentials.clone()).await;

        // Store credentials locally for cleanup
        {
            let mut store = self.credentials_store.write().await;
            store.insert(username.clone(), credentials.clone());

            // Clean up expired credentials
            let expired_usernames: Vec<String> = store
                .iter()
                .filter(|(_, creds)| now > creds.expires_at)
                .map(|(username, _)| username.clone())
                .collect();

            for username in expired_usernames {
                store.remove(&username);
            }
        }

        Some(credentials)
    }

    /// Clean up expired credentials periodically
    pub async fn cleanup_expired_credentials(&self) {
        let mut interval = tokio::time::interval(Duration::from_secs(30));

        loop {
            interval.tick().await;

            let now = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            let mut store = self.credentials_store.write().await;
            let expired_usernames: Vec<String> = store
                .iter()
                .filter(|(_, creds)| now > creds.expires_at)
                .map(|(username, _)| username.clone())
                .collect();

            for username in expired_usernames {
                store.remove(&username);
            }
        }
    }

    /// Get the TURN server address
    pub fn get_turn_url(&self) -> String {
        let port = self.listen_addr.port();
        match &self.public_ip {
            Some(ip) => format!("turn:{}:{}", ip, port),
            None => format!("turn:{}", self.listen_addr),
        }
    }

    /// Close the TURN server
    pub async fn close(&self) -> Result<()> {
        let mut server_guard = self.server.write().await;
        if let Some(server) = server_guard.take() {
            server
                .close()
                .await
                .map_err(|e| anyhow::anyhow!("Failed to close TURN server: {}", e))?;
        }
        Ok(())
    }
}
